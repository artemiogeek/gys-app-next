// ===================================================
// üöÄ Tests de Carga - Sistema GYS
// ===================================================
// Tests para simular 1000+ elementos y medir performance
// Validaci√≥n de rendimiento bajo condiciones de estr√©s

import React from 'react';
import { render, screen, waitFor, act } from '@testing-library/react';
import { performance } from 'perf_hooks';
import '@testing-library/jest-dom';

// üéØ Mocks necesarios
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  },
}));

jest.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,
    tr: ({ children, ...props }: any) => <tr {...props}>{children}</tr>,
  },
  AnimatePresence: ({ children }: any) => children,
}));

// üìä Interfaces para tests de carga
interface LoadTestResult {
  renderTime: number;
  memoryUsage: number;
  elementsCount: number;
  success: boolean;
  errors: string[];
}

interface PerformanceThresholds {
  maxRenderTime: number; // ms
  maxMemoryIncrease: number; // MB
  maxElementsForGoodPerformance: number;
}

// üéØ Constantes de testing
const PERFORMANCE_THRESHOLDS: PerformanceThresholds = {
  maxRenderTime: 100, // 100ms para 1000+ elementos
  maxMemoryIncrease: 50, // 50MB m√°ximo incremento
  maxElementsForGoodPerformance: 1000,
};

const LOAD_TEST_SCENARIOS = [
  { name: 'Small Load', elements: 100 },
  { name: 'Medium Load', elements: 500 },
  { name: 'Large Load', elements: 1000 },
  { name: 'Extra Large Load', elements: 2000 },
  { name: 'Stress Test', elements: 5000 },
];

// üß™ Componente de prueba para simular tabla pesada
interface TestTableProps {
  items: Array<{
    id: string;
    name: string;
    description: string;
    value: number;
    status: string;
    date: string;
  }>;
  enableVirtualization?: boolean;
}

const TestTable: React.FC<TestTableProps> = ({ items, enableVirtualization = false }) => {
  const startTime = performance.now();
  
  React.useEffect(() => {
    const endTime = performance.now();
    console.log(`TestTable rendered ${items.length} items in ${endTime - startTime}ms`);
  });

  if (enableVirtualization && items.length > 100) {
    // üîÑ Simulaci√≥n de virtualizaci√≥n
    const visibleItems = items.slice(0, 50); // Solo renderizar 50 elementos visibles
    
    return (
      <div data-testid="test-table" className="virtualized-table">
        <div data-testid="table-header">
          <span>ID</span>
          <span>Name</span>
          <span>Description</span>
          <span>Value</span>
          <span>Status</span>
          <span>Date</span>
        </div>
        <div data-testid="table-body">
          {visibleItems.map((item) => (
            <div key={item.id} data-testid={`table-row-${item.id}`}>
              <span>{item.id}</span>
              <span>{item.name}</span>
              <span>{item.description}</span>
              <span>{item.value}</span>
              <span>{item.status}</span>
              <span>{item.date}</span>
            </div>
          ))}
        </div>
        <div data-testid="virtualization-info">
          Showing 50 of {items.length} items (Virtualized)
        </div>
      </div>
    );
  }

  return (
    <div data-testid="test-table">
      <div data-testid="table-header">
        <span>ID</span>
        <span>Name</span>
        <span>Description</span>
        <span>Value</span>
        <span>Status</span>
        <span>Date</span>
      </div>
      <div data-testid="table-body">
        {items.map((item) => (
          <div key={item.id} data-testid={`table-row-${item.id}`}>
            <span>{item.id}</span>
            <span>{item.name}</span>
            <span>{item.description}</span>
            <span>{item.value}</span>
            <span>{item.status}</span>
            <span>{item.date}</span>
          </div>
        ))}
      </div>
    </div>
  );
};

// üè≠ Funci√≥n para generar datos de prueba
function generateTestData(count: number) {
  return Array.from({ length: count }, (_, index) => ({
    id: `item-${index + 1}`,
    name: `Test Item ${index + 1}`,
    description: `Description for test item ${index + 1} with some additional text to simulate real data`,
    value: Math.floor(Math.random() * 10000),
    status: ['active', 'inactive', 'pending', 'completed'][Math.floor(Math.random() * 4)],
    date: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
  }));
}

// üìä Funci√≥n para medir performance
function measurePerformance<T>(fn: () => T): { result: T; duration: number } {
  const startTime = performance.now();
  const result = fn();
  const endTime = performance.now();
  return {
    result,
    duration: endTime - startTime,
  };
}

// üíæ Funci√≥n para obtener uso de memoria (simulado)
function getMemoryUsage(): number {
  // En un entorno real, usar√≠amos performance.memory
  // Para tests, simulamos el uso de memoria
  if (typeof window !== 'undefined' && (window.performance as any)?.memory) {
    return (window.performance as any).memory.usedJSHeapSize;
  }
  return Math.random() * 50 * 1024 * 1024; // Simular 0-50MB
}

// üß™ Funci√≥n para ejecutar test de carga
async function runLoadTest(
  elementsCount: number,
  enableVirtualization = false
): Promise<LoadTestResult> {
  const errors: string[] = [];
  let renderTime = 0;
  let memoryBefore = 0;
  let memoryAfter = 0;

  try {
    // üìä Medir memoria inicial
    memoryBefore = getMemoryUsage();

    // üè≠ Generar datos de prueba
    const testData = generateTestData(elementsCount);

    // ‚è±Ô∏è Medir tiempo de renderizado
    const { duration } = measurePerformance(() => {
      return render(
        <TestTable 
          items={testData} 
          enableVirtualization={enableVirtualization}
        />
      );
    });

    renderTime = duration;

    // ‚úÖ Verificar que se renderiz√≥ correctamente
    await waitFor(() => {
      expect(screen.getByTestId('test-table')).toBeInTheDocument();
    });

    // üìä Medir memoria final
    memoryAfter = getMemoryUsage();

    // üîç Verificar elementos renderizados
    const tableBody = screen.getByTestId('table-body');
    const expectedElements = enableVirtualization && elementsCount > 100 ? 50 : elementsCount;
    const renderedRows = tableBody.children.length;

    if (renderedRows !== expectedElements) {
      errors.push(`Expected ${expectedElements} rows, but found ${renderedRows}`);
    }

  } catch (error) {
    errors.push(`Render error: ${error}`);
  }

  return {
    renderTime,
    memoryUsage: memoryAfter - memoryBefore,
    elementsCount,
    success: errors.length === 0,
    errors,
  };
}

// üß™ Suite de tests de carga
describe('üöÄ Load Testing - Performance under stress', () => {
  beforeEach(() => {
    // üßπ Limpiar DOM antes de cada test
    document.body.innerHTML = '';
    
    // üîÑ Limpiar mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    // üßπ Cleanup despu√©s de cada test
    document.body.innerHTML = '';
  });

  describe('üìä Basic Load Tests', () => {
    LOAD_TEST_SCENARIOS.forEach(({ name, elements }) => {
      it(`should handle ${name} (${elements} elements) within performance thresholds`, async () => {
        // üöÄ Ejecutar test de carga
        const result = await act(async () => {
          return runLoadTest(elements);
        });

        // ‚úÖ Verificar que el test fue exitoso
        expect(result.success).toBe(true);
        expect(result.errors).toHaveLength(0);
        expect(result.elementsCount).toBe(elements);

        // üìä Verificar thresholds de performance
        if (elements <= PERFORMANCE_THRESHOLDS.maxElementsForGoodPerformance) {
          expect(result.renderTime).toBeLessThan(PERFORMANCE_THRESHOLDS.maxRenderTime);
        }

        // üíæ Verificar uso de memoria
        const memoryIncreaseMB = result.memoryUsage / (1024 * 1024);
        expect(memoryIncreaseMB).toBeLessThan(PERFORMANCE_THRESHOLDS.maxMemoryIncrease);

        // üìù Log de resultados
        console.log(`${name} Results:`, {
          elements: result.elementsCount,
          renderTime: `${result.renderTime.toFixed(2)}ms`,
          memoryIncrease: `${memoryIncreaseMB.toFixed(2)}MB`,
          withinThresholds: result.renderTime < PERFORMANCE_THRESHOLDS.maxRenderTime,
        });
      });
    });
  });

  describe('üîÑ Virtualization Performance Tests', () => {
    it('should improve performance with virtualization for large datasets', async () => {
      const elementsCount = 2000;

      // üöÄ Test sin virtualizaci√≥n
      const resultWithoutVirtualization = await act(async () => {
        return runLoadTest(elementsCount, false);
      });

      // üßπ Limpiar DOM
      document.body.innerHTML = '';

      // üîÑ Test con virtualizaci√≥n
      const resultWithVirtualization = await act(async () => {
        return runLoadTest(elementsCount, true);
      });

      // ‚úÖ Verificar que ambos tests fueron exitosos
      expect(resultWithoutVirtualization.success).toBe(true);
      expect(resultWithVirtualization.success).toBe(true);

      // üìä Verificar mejora de performance con virtualizaci√≥n
      expect(resultWithVirtualization.renderTime).toBeLessThan(
        resultWithoutVirtualization.renderTime
      );

      // üíæ Verificar menor uso de memoria con virtualizaci√≥n
      expect(resultWithVirtualization.memoryUsage).toBeLessThan(
        resultWithoutVirtualization.memoryUsage
      );

      // üìù Log de comparaci√≥n
      console.log('Virtualization Comparison:', {
        withoutVirtualization: {
          renderTime: `${resultWithoutVirtualization.renderTime.toFixed(2)}ms`,
          memory: `${(resultWithoutVirtualization.memoryUsage / 1024 / 1024).toFixed(2)}MB`,
        },
        withVirtualization: {
          renderTime: `${resultWithVirtualization.renderTime.toFixed(2)}ms`,
          memory: `${(resultWithVirtualization.memoryUsage / 1024 / 1024).toFixed(2)}MB`,
        },
        improvement: {
          renderTime: `${((1 - resultWithVirtualization.renderTime / resultWithoutVirtualization.renderTime) * 100).toFixed(1)}%`,
          memory: `${((1 - resultWithVirtualization.memoryUsage / resultWithoutVirtualization.memoryUsage) * 100).toFixed(1)}%`,
        },
      });
    });
  });

  describe('üéØ Performance Regression Tests', () => {
    it('should maintain consistent performance across multiple renders', async () => {
      const elementsCount = 1000;
      const iterations = 5;
      const results: LoadTestResult[] = [];

      // üîÑ Ejecutar m√∫ltiples iteraciones
      for (let i = 0; i < iterations; i++) {
        const result = await act(async () => {
          return runLoadTest(elementsCount);
        });
        
        results.push(result);
        
        // üßπ Limpiar DOM entre iteraciones
        document.body.innerHTML = '';
      }

      // ‚úÖ Verificar que todos los tests fueron exitosos
      results.forEach((result, index) => {
        expect(result.success).toBe(true);
        expect(result.errors).toHaveLength(0);
      });

      // üìä Calcular estad√≠sticas
      const renderTimes = results.map(r => r.renderTime);
      const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / renderTimes.length;
      const maxRenderTime = Math.max(...renderTimes);
      const minRenderTime = Math.min(...renderTimes);
      const variance = renderTimes.reduce((sum, time) => sum + Math.pow(time - avgRenderTime, 2), 0) / renderTimes.length;
      const standardDeviation = Math.sqrt(variance);

      // üéØ Verificar consistencia (desviaci√≥n est√°ndar < 20% del promedio)
      const consistencyThreshold = avgRenderTime * 0.2;
      expect(standardDeviation).toBeLessThan(consistencyThreshold);

      // üìù Log de estad√≠sticas
      console.log('Performance Consistency Results:', {
        iterations,
        avgRenderTime: `${avgRenderTime.toFixed(2)}ms`,
        minRenderTime: `${minRenderTime.toFixed(2)}ms`,
        maxRenderTime: `${maxRenderTime.toFixed(2)}ms`,
        standardDeviation: `${standardDeviation.toFixed(2)}ms`,
        consistencyScore: `${((1 - standardDeviation / avgRenderTime) * 100).toFixed(1)}%`,
      });
    });
  });

  describe('üö® Stress Testing', () => {
    it('should handle extreme load gracefully', async () => {
      const extremeLoad = 10000;
      
      // üöÄ Ejecutar test de estr√©s
      const result = await act(async () => {
        return runLoadTest(extremeLoad, true); // Usar virtualizaci√≥n para carga extrema
      });

      // ‚úÖ Verificar que el componente no fall√≥
      expect(result.success).toBe(true);
      expect(result.errors).toHaveLength(0);

      // üìä El tiempo puede ser alto, pero debe completarse
      expect(result.renderTime).toBeGreaterThan(0);
      expect(result.renderTime).toBeLessThan(5000); // M√°ximo 5 segundos

      // üíæ Verificar que la memoria no se dispar√≥ excesivamente
      const memoryIncreaseMB = result.memoryUsage / (1024 * 1024);
      expect(memoryIncreaseMB).toBeLessThan(200); // M√°ximo 200MB para carga extrema

      // üìù Log de resultados de estr√©s
      console.log('Stress Test Results:', {
        elements: result.elementsCount,
        renderTime: `${result.renderTime.toFixed(2)}ms`,
        memoryIncrease: `${memoryIncreaseMB.toFixed(2)}MB`,
        status: 'PASSED',
      });
    });
  });

  describe('üìà Performance Benchmarking', () => {
    it('should generate performance benchmark report', async () => {
      const benchmarkScenarios = [
        { name: 'Baseline', elements: 100 },
        { name: 'Target Load', elements: 1000 },
        { name: 'High Load', elements: 2000 },
      ];

      const benchmarkResults = [];

      // üöÄ Ejecutar todos los escenarios
      for (const scenario of benchmarkScenarios) {
        const result = await act(async () => {
          return runLoadTest(scenario.elements);
        });

        benchmarkResults.push({
          ...scenario,
          ...result,
        });

        // üßπ Limpiar DOM
        document.body.innerHTML = '';
      }

      // ‚úÖ Verificar que todos los benchmarks fueron exitosos
      benchmarkResults.forEach(result => {
        expect(result.success).toBe(true);
      });

      // üìä Generar reporte de benchmark
      const benchmarkReport = {
        timestamp: new Date().toISOString(),
        scenarios: benchmarkResults.map(result => ({
          name: result.name,
          elements: result.elementsCount,
          renderTime: `${result.renderTime.toFixed(2)}ms`,
          memoryUsage: `${(result.memoryUsage / 1024 / 1024).toFixed(2)}MB`,
          performanceScore: Math.max(0, 100 - (result.renderTime / 10)), // Score basado en tiempo
        })),
        summary: {
          totalTests: benchmarkResults.length,
          successRate: '100%',
          avgRenderTime: `${(benchmarkResults.reduce((sum, r) => sum + r.renderTime, 0) / benchmarkResults.length).toFixed(2)}ms`,
        },
      };

      // üìù Log del reporte completo
      console.log('üìä Performance Benchmark Report:', JSON.stringify(benchmarkReport, null, 2));

      // ‚úÖ Verificar que el reporte se gener√≥ correctamente
      expect(benchmarkReport.scenarios).toHaveLength(benchmarkScenarios.length);
      expect(benchmarkReport.summary.successRate).toBe('100%');
    });
  });
});