// ===================================================
// üìÅ Archivo: route.ts
// üìå Crea una cotizaci√≥n nueva basada en una plantilla
// ===================================================

import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { generateNextCotizacionCode } from '@/lib/utils/cotizacionCodeGenerator'

// ‚úÖ Type for PlantillaServicio with proper fields
type PlantillaServicioWithItems = {
  id: string
  nombre: string
  categoria: string
  descripcion?: string | null
  subtotalInterno: number
  subtotalCliente: number
  items: any[]
}

export async function POST(req: Request) {
  const session = await getServerSession(authOptions)
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'No autorizado' }, { status: 401 })
  }

  try {
    const body = await req.json()
    const { plantillaId, clienteId } = body
    console.log('üîç [DEBUG] Iniciando creaci√≥n de cotizaci√≥n desde plantilla')
    console.log('üìã [DEBUG] Datos recibidos:', { plantillaId, clienteId })
    console.log('üîç [DEBUG] Sesi√≥n del usuario:', {
      userId: session.user.id,
      userEmail: session.user.email,
      userName: session.user.name
    })

    if (!plantillaId || typeof plantillaId !== 'string') {
      console.log('‚ùå [DEBUG] Faltan datos requeridos - plantillaId')
      return NextResponse.json({ error: 'ID de plantilla requerido' }, { status: 400 })
    }
    if (!clienteId || typeof clienteId !== 'string') {
      console.log('‚ùå [DEBUG] Faltan datos requeridos - clienteId')
      return NextResponse.json({ error: 'Debe seleccionar un cliente' }, { status: 400 })
    }

    // ‚úÖ Verificar que el cliente existe antes de continuar
    console.log('üîç [DEBUG] Verificando cliente...')
    const cliente = await prisma.cliente.findUnique({
      where: { id: clienteId },
    })

    if (!cliente) {
      console.log('‚ùå [DEBUG] Cliente no encontrado:', clienteId)
      return NextResponse.json({ error: 'Cliente no v√°lido' }, { status: 400 })
    }
    console.log('‚úÖ [DEBUG] Cliente encontrado:', cliente.nombre)

    // ‚úÖ Obtener plantilla con validaci√≥n de foreign keys
    const plantilla = await prisma.plantilla.findUnique({
      where: { id: plantillaId },
      include: {
        equipos: { include: { items: true } },
        servicios: { 
          include: { 
            items: {
              include: {
                recurso: true, // ‚úÖ Validar que el recurso existe
                unidadServicio: true, // ‚úÖ Validar que la unidad de servicio existe
              }
            } 
          } 
        },
        gastos: { include: { items: true } },
      },
    })

    if (!plantilla) {
      return NextResponse.json({ error: 'Plantilla no encontrada' }, { status: 404 })
    }

    // ‚úÖ Validar que todos los servicios tienen recursos y unidades v√°lidos
    for (const servicio of plantilla.servicios) {
      for (const item of servicio.items) {
        if (!item.recursoId || !item.unidadServicioId) {
          return NextResponse.json({ 
            error: `El servicio '${item.nombre}' tiene referencias inv√°lidas. Recurso: ${item.recursoId}, Unidad: ${item.unidadServicioId}` 
          }, { status: 400 })
        }
      }
    }

    // ‚úÖ Generar c√≥digo autom√°tico de cotizaci√≥n
    console.log('üîç [DEBUG] Generando c√≥digo autom√°tico de cotizaci√≥n...')
    const { codigo, numeroSecuencia } = await generateNextCotizacionCode()
    console.log('‚úÖ [DEBUG] C√≥digo generado:', { codigo, numeroSecuencia })

    const baseData = {
      codigo, // ‚úÖ C√≥digo autom√°tico formato GYS-XXXX-YY
      numeroSecuencia, // ‚úÖ N√∫mero secuencial
      nombre: `Cotizaci√≥n de ${plantilla.nombre}`,
      clienteId,
      comercialId: session.user.id, // Se actualizar√° m√°s adelante si es necesario
      plantillaId: plantilla.id,
      totalInterno: plantilla.totalInterno,
      totalCliente: plantilla.totalCliente,
      totalEquiposInterno: plantilla.totalEquiposInterno,
      totalEquiposCliente: plantilla.totalEquiposCliente,
      totalServiciosInterno: plantilla.totalServiciosInterno,
      totalServiciosCliente: plantilla.totalServiciosCliente,
      totalGastosInterno: plantilla.totalGastosInterno,
      totalGastosCliente: plantilla.totalGastosCliente,
      descuento: plantilla.descuento,
      grandTotal: plantilla.grandTotal,
      equipos: {
        create: plantilla.equipos.map(e => ({
          nombre: e.nombre,
          descripcion: e.descripcion,
          subtotalInterno: e.subtotalInterno,
          subtotalCliente: e.subtotalCliente,
          items: {
            create: e.items.map(item => ({
              catalogoEquipoId: item.catalogoEquipoId,
              codigo: item.codigo,
              descripcion: item.descripcion,
              categoria: item.categoria,
              unidad: item.unidad,
              marca: item.marca,
              cantidad: item.cantidad,
              precioInterno: item.precioInterno,
              precioCliente: item.precioCliente,
              costoInterno: item.costoInterno,
              costoCliente: item.costoCliente,
            })),
          },
        })),
      },
      servicios: {
        create: plantilla.servicios.map((s: PlantillaServicioWithItems) => ({
          nombre: s.nombre,
          categoria: s.categoria,
          subtotalInterno: Number(s.subtotalInterno),
          subtotalCliente: Number(s.subtotalCliente),
          items: {
            create: s.items.map(item => ({
              catalogoServicioId: item.catalogoServicioId,
              categoria: item.categoria,
              unidadServicioId: item.unidadServicioId, // ‚úÖ Campo obligatorio
              recursoId: item.recursoId, // ‚úÖ Campo obligatorio
              unidadServicioNombre: item.unidadServicioNombre,
              recursoNombre: item.recursoNombre,
              formula: item.formula,
              horaBase: item.horaBase,
              horaRepetido: item.horaRepetido,
              horaUnidad: item.horaUnidad,
              horaFijo: item.horaFijo,
              costoHora: item.costoHora,
              nombre: item.nombre,
              descripcion: item.descripcion,
              cantidad: item.cantidad,
              horaTotal: item.horaTotal,
              factorSeguridad: item.factorSeguridad || 1.0, // ‚úÖ Valor por defecto
              margen: item.margen,
              costoInterno: item.costoInterno,
              costoCliente: item.costoCliente,
            })),
          },
        })),
      },
      gastos: {
        create: plantilla.gastos.map(g => ({
          nombre: g.nombre,
          subtotalInterno: g.subtotalInterno,
          subtotalCliente: g.subtotalCliente,
          items: {
            create: g.items.map(item => ({
              nombre: item.nombre,
              descripcion: item.descripcion,
              cantidad: item.cantidad,
              precioUnitario: item.precioUnitario,
              factorSeguridad: item.factorSeguridad,
              margen: item.margen,
              costoInterno: item.costoInterno,
              costoCliente: item.costoCliente,
            })),
          },
        })),
      },
    }

    // Crear la cotizaci√≥n base
    console.log('üîç [DEBUG] Creando cotizaci√≥n base...')
    console.log('üìã [DEBUG] Datos para cotizaci√≥n:', {
      clienteId,
      comercialId: session.user.id,
      plantillaNombre: plantilla.nombre,
      equiposCount: plantilla.equipos.length,
      serviciosCount: plantilla.servicios.length,
      gastosCount: plantilla.gastos.length
    })
    
    // Verificar que los IDs de foreign keys existen
    console.log('üîç [DEBUG] Verificando foreign keys...')
    
    // Verificar cliente
    const clienteExists = await prisma.cliente.findUnique({ where: { id: clienteId } })
    if (!clienteExists) {
      console.error('‚ùå Cliente no encontrado:', clienteId)
      return NextResponse.json({ error: 'Cliente no encontrado' }, { status: 400 })
    }
    
    // Verificar comercial (usuario) - usar el usuario que existe en la BD
    let comercialId = session.user.id
    let comercialExists = await prisma.user.findUnique({ where: { id: comercialId } })
    
    if (!comercialExists) {
      console.log('‚ö†Ô∏è [DEBUG] Usuario de sesi√≥n no encontrado, buscando usuario alternativo...')
      // Buscar cualquier usuario admin disponible
      const adminUser = await prisma.user.findFirst({ where: { role: 'admin' } })
      if (adminUser) {
        comercialId = adminUser.id
        comercialExists = adminUser
        console.log('‚úÖ [DEBUG] Usando usuario admin:', { id: adminUser.id, email: adminUser.email })
      } else {
        console.error('‚ùå No hay usuarios disponibles en la base de datos')
        return NextResponse.json({ error: 'No hay usuarios disponibles' }, { status: 500 })
      }
    }
    
    // Actualizar baseData con el comercialId correcto
    baseData.comercialId = comercialId
    
    console.log('‚úÖ [DEBUG] Foreign keys verificados correctamente')
    console.log('üìã [DEBUG] Usando comercialId:', comercialId)
    
    const cotizacion = await prisma.cotizacion.create({ data: baseData })
    console.log('‚úÖ [DEBUG] Cotizaci√≥n base creada:', cotizacion.id)
    return NextResponse.json(cotizacion)
  } catch (error: any) {
    console.error('‚ùå Error inesperado:', error)
    return NextResponse.json({ error: error?.message || 'Error inesperado' }, { status: 500 })
  }
}
